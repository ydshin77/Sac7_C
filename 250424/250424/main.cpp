
/*
일자 : 25.04.24
작성자 : 민예인
내용 : C++ 기초
*/

// 앞에 #이 붙으면 전처리기 (컴파일 단계 전에 처리하는 구문)

// #include는 뒤에 있는 헤더파일을 여기에 포함시켜
//해당 헤더파일의 코드를 여기에서 사용할 수 있도록 함
#include <iostream>

/*
using namespace : 뒤에 있는 namespace를 사용하겠다는 의미, std:: 생략이 가능함
ex) using namespace std;
*/

void main()
{
	/*
	'' : 문자 1개를 표현함, 알파벳 혹은 숫자, 한글은 2바이트라서 안됨
	"" : 문자 여러 개(문자열)를 표현함
	\n : 개행문자(줄바꿈), 개행의 위치는 아무 데나 가능
	*/

	printf("출력 테스트\n");
	printf("두 번째 출력\n");

	/*
	:: 스코프 연산자, 범위를 지정할 때 사용함
	ex) std::cout는 std namespace 안의 cout
	*/

	std::cout << "세 번째 출력\n";

	/*
	용량의 최소 단위 : bit
	1bit는 0, 1 둘 중에 하나의 값을 저장할 수 있는 공간
	1byte : 8bit
	1kbyte : 1024byte
	1mbyte : 1024kbyte
	1gbyte : 1024mbyte
	1tbyte : 1024gbyte

	변수와 상수
	변수 : 값을 변경할 수 있는 숫자
	상수 : 값을 변경할 수 없는 숫자
	메모리에 공간을 만들고 변수나 상수의 값을 저장해둠

	크기 : byte 단위
	문자 표현시 한글, 한자는 2바이트를 차지함
	문자는 값을 저장하고 값에 해당하는 문자를 ASCII 코드에서 찾아서 표현함

	signed : +, - 부호가 있음 -> 기본
	unsigned : 부호가 없다. (+만 있음)

	표현 범위를 벗어나면 동작되는 방식
	최대값 이상 : 최소값으로 전환
	최소값 이하 : 최대값으로 전환
	INT_MAX : int로 표현할 수 있는 최대값

	타입	|	크기 |	종류	|	표현범위
	bool	|	1	 |	참/거짓	|	false(0) - true(1)
	char	|	1	 |	문자	|	-128 ~ 127 -> unsigned 0 ~ 255
	short	|	2	 |	정수	|	-32768 ~ 32767 -> unsigned 0 ~ 65535
	int		|	4	 |	정수	|	-2147483648 ~ 2147483647
	__int64	|	8	 |	정수	|
	float	|	4	 |	실수	|
	double	|	8	 |	실수	|

	변수 선언 방법 : 변수타입 변수명;
	변수명은 알파벳, 숫자, _만 사용 가능
	변수명의 시작은 알파벳, _만 가능
	*/

	// 변수는 선언하면 쓰레기값이 들어가 있음
	// 그렇기 때문에 선언과 동시에 초기화를 해주고 사용하는 것이 안전함
	bool TestBool = false;
	TestBool = true;

	int Number = 100;

	// 변수 타입 왼쪽에 const를 붙이면 상수 선언이 됨
	const int cNumber = 200;
	// cNumber = 300;

	char Text = 'C';
	// -128 ~ 127 사이의 값을 unsigned를 붙여 0 ~ 255로 표현범위를 바꿔주었음
	unsigned char Text1 = 203;

	// -32768 ~ 32767
	short Number1 = -32769;

	// cout에 변수를 넣으면 변수가 가지고 있는 값을 출력함
	std::cout << Number1 << "\n";

	// 소수점 뒤에 f를 붙이면 float타입 실수가 됨
	// f가 없으면 double 타입 실수가 됨
	float Number2 = 3.14567121323f;

	std::cout << Number2 << "\n";

	double Number3 = 3.123234123134;

	Number = 3.14f;

	std::cout << Number << "\n";


	/*
	대입연산자 : = , 오른쪽의 값을 왼쪽의 변수에 대입 (상수는 대입이 불가함)

	연산자 우선순위 : 연산자들끼리 연산되는 순서를 결정

	수학 : (), {}, []
	C++ : ()

	사칙연산자 : +, -, *, /, %(나머지 연산)
	연산자 우선순위) *, /, % > +, -

	나머지 연산은 A를 B로 나눈 나머지 값을 구해줌
	10 % 3 = 1

	// 나머지 연산은 정수 대 정수 연산을 지원
	// Number = 3.14ff % 322.33f;

	나눗셈 연산을 할 때 결과값을 실수형태로 얻고 싶다면
	나눗셈을 수행하는 2개의 값중 1개라도 실수여야 함
	A / B 를 수행할 때 둘 다 정수라면 결과도 정수로 나오고 소수점이 잘림
	10 / 3 = 3
	*/

	/*
	%d : 정수값을 받아서 문자열로 변경
	%f : 실수값을 받아서 문자열로 변경
	%c : 문자 1개를 받아서 문자열로 변경
	%s : 문자열을 받아서 문자열로 변경
	*/

	Number = 10 % 3;

	printf("10 %% 3 = %d\n", Number);
	// %나 /를 출력할 때는 2개를 붙여줘야 됨

	// 	Number = 10 / 0;

	int Number11 = 10, Number12 = 0;
	// Number = Number / Number12;
	printf("10 / 3 = %d\n", (10 / 3));
	//Number = 10 / 0;
	// 0으로 나누면 프로그램이 죽음 -> 에러
	//Number = 0 / 10;


	// %.3f 하면 소수점 3번째 자리까지 출력한다는 의미
	// 3.0f = 3.f;
	printf("10/3 = %.3f\n", (10 / 3.0f));

	/*
	관계연산자 : 두 값을 비교하는 연산자
	결과로 참/거짓이 나옴
	<, >, <=, >=, ==(같다), !=(같지 않다)
	*/

	bool Result = 10 < 20;
	printf("10 < 20 = %d\n", Result);
	Result = 10 > 20;
	printf("10 > 20 = %d\n", Result);
	Result = 10 <= 20;
	printf("10 <= 20 = %d\n", Result);
	Result = 10 >= 20;
	printf("10 >= 20 = %d\n", Result);
	Result = 10 == 20;
	printf("10 == 20 = %d\n", Result);
	Result = 10 != 20;
	printf("10 != 20 = %d\n", Result);
	// 사칙 연산자가 관계연산자보다 우선순위가 높음
	Result = 10 + 7 > 20 + 2;
	printf("10 + 7 >  20 + 2 = %d\n", Result);

	/*
	논리연산자 : 참/거짓 대 참/거짓을 연산하여 결과로 참/거짓이 나오는 연산자
	AND(&&), OR(||), NOT(!)
	AND : 둘 다 참일 경우만 참이고 아니면 거짓
	> 스킬을 써야돼! 마나량이랑 스킬 쿨타임이 둘 다 충족하는지 확인하자!
	OR : 둘 중 하나라도 참이면 참이고 아니면 거짓
	A	B	AND		OR
	0	0	 0		0
	1   0	 0		1
	0   1	 0		1
	1   1	 1		1

	NOT : 참이면 거짓으로, 거짓이면 참으로 바꿔준다.
	A	NOT
	0	1
	1	0
	*/

	printf("false && false = %d\n", false && false);
	printf("true && false = %d\n", true && false);
	printf("false && true = %d\n", false && true);
	printf("true && true = %d\n", true && true);

	printf("false || false = %d\n", false || false);
	printf("true || false = %d\n", true || false);
	printf("false || true = %d\n", false || true);
	printf("true || true = %d\n", true || true);

	printf("!false = %d\n", !false);
	printf("!true = %d\n", !true);

	int MP = 70;
	float CoolDown = 0.f;

	// 스킬 사용 조건 : 마나가 50 이상이고 스킬 쿨다운이 0초일 경우
	Result = MP >= 50 && CoolDown == 0.f;

	printf("Skill On : %d\n", Result);

	/*
	2진수 : 0, 1 둘 중 하나로 표현
	10진수: 0 ~ 9 사이의 숫자로 표현
	16진수 : 0 ~ 15까지 표현
	10 ~ 15는 두 자리를 차지하기 때문에 a ~ f로 표현

	10진수 213을 2진수, 16진수로 변환해보자.

	213 / 2 = 106 -- 1
	106 / 2 = 53 --- 0
	53 / 2 = 26 ---- 1
	26 / 2 = 13 ---- 0
	13 / 2 = 6 ----- 1
	6 / 2 = 3 ------ 0
	3 / 2 = 1 ------ 1

	더이상 2로 나눌 수 없다면 마지막 몫부터 거꾸로 읽음
	213 = 11010101

	2진수는 앞에 0b를 붙여서 표현 (0b11010101)

	1   1  0   1 0 1 0 1
	128 64 32 16 8 4 2 1

	128 + 64 + 16 + 4 + 1 = 213

	16진수 1자리는 2진수 4자리를 차지함
	1101 / 0101
	8421 / 8421

	16진수는 앞에 0x를 붙여서 표현함 (0xd5)

	5 / 2 = 2 -- 1
	2 / 2 = 1 -- 0

	13 / 2 = 6 -- 1
	6 / 2 = 3 -- 0
	3 / 2 = 1 -- 1

	11010101

	2진수 단위의 연산은 2가지가 제공됨
	비트단위 논리연산자, 쉬프트 연산자
	값 대 값을 연산하여 결과로 값이 나오게 됨.

	비트단위 논리연산자 : AND(&), OR(|), NOT(~), XOR(^)
	A와 B를 연산하게 되면 먼저 A와 B를 2진수로 변환하고
	각 자리별로 논리연산을 수행함

	A	B	XOR
	0	0	0
	1	0	1
	0	1	1
	1	1	0

	213 = 11010101
	479 = 111011111

	479 & 213 =
	 111011111
	&011010101
	=011010101

	479 | 213 =
	 111011111
	|011010101
	=111011111

	479 ^ 213 =
	 111011111
	^011010101
	=100001010
	256 + 8 + 2 = 266

	~213 = -214

	~ 00000000 00000000 00000000 11010101
	  11111111 11111111 11111111 00101010
	*/
	printf("479 & 213 = %d\n", (479 & 213));
	printf("479 | 213 = %d\n", (479 | 213));
	printf("479 ^ 213 = %d\n", (479 ^ 213));
	printf("~213 = %d\n", (~213));

	// 0x00000001와 0x1은 같다.
	// 0x00000001 : 1
	// 0x00000002 : 10
	// 0x00000004 : 100
	// 0x00000008 : 1000
	// 0x00000010 : 10000
	const int Attack = 0x00000001;
	const int Defense = 0x00000002;
	const int HPBuf = 0x00000004;
	const int MPBuf = 0x00000008;
	const int Critical = 0x00000010;

	// 버프 30개를 bool로 하게 된다면 30바이트
	// 근데 비트를 이용한다면 int 한개(4바이트)로 해결 가능

	int Buf = 0;

	// Buf = 0 | 1 = 1
	Buf = Buf | Attack;
	// Buf = 001 | 100 = 101
	Buf = Buf | HPBuf;

	// Buf = 00101 | 10000 = 10101
	Buf = Buf | Critical;

	// Buf = 10101 ^ 00100 = 10001
	Buf = Buf ^ HPBuf;

	// Buf = 10001 ^ 00100 = 10101
	Buf = Buf ^ HPBuf;
	// 버프를 제거하고 싶으면 먼저 버프가 켜져 있는지 확인하고 xor 진행
	// 있을 때 xor하면 꺼지고, 다시 xor하면 켜짐

	// or을 사용하면 각 자리수가 켜짐, 원하는 버프를 킬 수 있음
	// and를 사용하면 버프가 켜져있는지 확인 가능, 0은 거짓, 나머지는 다 참이라서

	printf("Attack : %d\n", (Buf & Attack));
	printf("Defense : %d\n", (Buf & Defense));
	printf("HPBuf : %d\n", (Buf & HPBuf));
	printf("MPBuf : %d\n", (Buf & MPBuf));
	printf("Critical : %d\n", (Buf & Critical));

	/*
	01100100
	10011011
	*/

	/*
	쉬프트연산자 : <<, >>
	cout 할 때 썼던 것과는 다름
	10 : 1010
	10 << 2 = 101000 = 40
	10 << 3 = 1010000= 80
	2의 n승단위의 곱셈연산을 빠르게 할 때 사용

	80 >> 2 = 10100 = 20
	80 >> 3 = 1010 = 10
	2의 n승단위의 나눗셈연산을 빠르게 할 때 사용

	게임에서 렌더링 작업(컬러연산)할 때 사용
	*/

	/*
	증감연산자 : ++, --

	++ : 1증가
	-- : 1감소
	*/

	int Number100 = 0;

	// Number100 = Number100 + 20;
	Number100 += 20;

}

