
#include <iostream>

// 데이터 영역
int gNumber;

/*
C++의 메모리 영역

=====================

지역변수 : 함수 안에서 선언하는 변수
-> 지역변수가 선언된 함수 안에서 사용할 수 있고 함수가 종료되면 메모리에서 제거됨

전역변수 : 함수 바깥에 선언하는 변수
-> 전역변수가 선언된 아래의 모든 곳에서 전역변수에 접근하여 사용할 수 있음
-> 초기화하지 않을 경우 자동으로 0으로 초기화됨

정적변수 : static 키워드를 이용하여 선언된 변수
-> 전역변수, 지역변수 모두 static 키워드를 붙일 수 있음
-> 지역변수에 static을 붙여서 변수를 선언하면 
   해당 변수는 초기화를 하지 않을 경우 0으로 자동 초기화가 되고 초기화 코드는 단 1번만 동작함
-> 함수가 종료되어도 메모리가 유지됨

전역/전적 변수는 프로그램이 종료될 때 메모리에서 제거됨
-> 잘 쓰지 않는 이유 (필요 없을 때 제거할 수 없기 때문) / 테스트 용도로는 종종 사용함

1. 스택 : 지역변수, 함수 인자의 메모리를 생성하는 공간
-> 함수가 종료되면 메모리를 제거함 / 크기 제한이 있음 (스택오버플로우)

2. 데이터 : 전역변수, 정적변수의 메모리를 생성하는 공간
-> 초기화된 데이터 영역 : 초기값이 있는 전역/정적 변수
-> BSS 영역 : 초기값이 없는 전역/정적 변수 (자동으로 0 초기화된 변수들)

3. 힙 : 동적할당된 메모리를 생성하는 공간 (C언어 : malloc 등, C++ : new)
-> 동적할당된 메모리는 프로그래머가 필요없을 때 반드시 제거를 해줘야 함
   (프로그램이나 함수가 종료될 때 자동으로 제거되지 않기 때문)

4. 코드 : 바이너리코드가 저장되는 영역, 함수도 코드이기 때문에 여기에 저장됨
-> 이런 특징 때문에 함수도 주소를 가질 수 있음 == 함수도 포인터를 만들 수 있다는 걸 의미
-> 값 변경 불가 (읽기 전용)
*/

// 코드 영역
void Test()
{
	gNumber = 200;

	// 데이터 영역
	static int Num1 = 200;

	printf("Num1 : %d\n", Num1);

	++Num1;
}

// 동적할당 메모리 주소를 알 수 없어 메모리 릭 발생
void Alloc(int* Addr)
{
	Addr = new int;
}

// 이런 형식으로 많이 쓰임(이중포인터)
void Alloc(int** Addr)
{
	*Addr = new int;
}

int main()
{
	// 스택 영역
	int Number = 111;

	Test();
	Test();
	Test();
	Test();
	Test();

	printf("gNumber : %d\n", gNumber);


	/*
	new를 이용해서 동적할당을 하고, delete를 이용해서 동적할당된 메모리를 제거할 수 있음
	-> 원할 때 생성하고 제거할 수 있다는 것이 동적할당의 장점

	new와 delete는 연산자임

	new를 이용해서 생성한 메모리를 delete를 이용해서 제거하지 않으면?
	메모리 릭이 발생하게 됨 (메모리를 계속 쓰고 있는 걸로 인지) -> 게임에서 크리티컬한 이슈

	(동적할당 예시)
	몬스터 잡고 아이템이 드랍될 때 -> 아이템을 구성하는 메모리를 만들어야 함
	-> 아이템을 안먹으면 남아있어야 함 -> 먹으면 인벤토리에 저장
	보스 처치 시 일정 시간 이후 다시 생성
	
	new 변수타입; 을 해주면 변수타입의 크기만큼 힙에 메모리를 생성하고 그 주소를 반환해줌
	delete 주소; 를 해주면 해당 주소를 메모리 해제해줌, 반드시 동적할당된 주소만 넣어야 함

	c언어에서는 malloc, free 함수를 이용해서 동적할당하고 해제함 / c++과의 차이점(c++은 연산자)
	*/

	// 언리얼엔진에서 new, delete는 거의 안쓰지만(내부에서 릭이 안생기게 관리해주기 때문에)
	// 멀티쓰레드를 쓸 때는 메모리 관리를 안해주기 때문에 가끔 쓰임

	// 12바이트 할당 > NumAddr 포인터 변수가 스택에 8바이트, new int는 힙에 4바이트
	int* NumAddr = new int;
	// new int*;	// int 의 크기만큼 메모리 공간을 만들고 그 주소 반환
	*NumAddr = 300;
	delete NumAddr;

	// 동적배열을 만들고 그 시작주소를 반환해줌
	int* Array = new int[30];
	Array[4] = 10;
	delete[] Array;

	int* Addr = nullptr;
	
	// 메모리 릭 발생, 동적할당된 메모리의 주소를 알 수 없어서
	Alloc(Addr);

	// 이런 형태로 많이 쓰임 (이중포인터형태) -> 주소를 이용한 반환형태 (call by address)
	// call by value : 함수 호출 후 결과를 받을 때 / call by reference
	// 세가지 형태 개념 숙지, 외워놓기
	Alloc(&Addr);
	*Addr = 500;
	delete Addr;

	return 0;
}